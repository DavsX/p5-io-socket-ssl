Index: MANIFEST
===================================================================
--- MANIFEST	(revision 402)
+++ MANIFEST	(working copy)
@@ -82,6 +82,7 @@
 t/external/08_external.t
 t/external/15_altnames.t
 t/external/20_cert_chain.t
+t/external/ocsp.t
 t/handle/external/10_destroy.t
 t/handle/external/50_external.t
 t/handle/local/05_use.t
Index: SSLeay.xs
===================================================================
--- SSLeay.xs	(revision 402)
+++ SSLeay.xs	(working copy)
@@ -115,6 +115,15 @@
  *        OUTPUT:
  *            RETVAL
  *
+ * 
+ * Runtime debugging:
+ *
+ * with TRACE(level,fmt,...) you can output debug messages.
+ * it behaves the same as 
+ *   warn sprintf($msg,...) if $Net::SSLeay::trace>=$level
+ * would do in Perl (e.g. it is using also the $Net::SSLeay::trace variable)
+ *
+ *
  * THE LAST RULE:
  *
  * The fact that some parts of SSLeay.xs do not follow the rules above is not 
@@ -131,6 +140,7 @@
 #include "EXTERN.h"
 #include "perl.h"
 #include "XSUB.h"
+#include <stdarg.h>
 #define NEED_newRV_noinc
 #define NEED_sv_2pv_flags
 #define NEED_my_snprintf
@@ -174,6 +184,9 @@
 #ifdef OPENSSL_FIPS
 #include <openssl/fips.h>
 #endif
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+#include <openssl/ocsp.h>
+#endif
 #undef BLOCK
 
 /* Debugging output - to enable use:
@@ -195,6 +208,17 @@
 #define PR4(s,t,u,v)
 #endif
 
+static void TRACE(int level,char *msg,...) {
+    va_list args;
+    SV *trace = get_sv("Net::SSLeay::trace",0);
+    if (trace && SvIOK(trace) && SvIV(trace)>=level) {
+	char buf[4096];
+	va_start(args,msg);
+	vsnprintf(buf,4095,msg,args);
+	warn("%s",buf);
+    }
+}
+
 #include "constants.c"
 
 /* ============= thread-safety related stuff ============== */
@@ -713,6 +737,54 @@
 
 #endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L && !defined(OPENSSL_NO_TLSEXT)
+
+int tlsext_status_cb_invoke(SSL *ssl, void *arg)
+{
+    dSP;
+    SV *cb_func, *cb_data;
+    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);
+    int len,res,nres = -1;
+    const unsigned char *p = NULL;
+    OCSP_RESPONSE *ocsp_response = NULL;
+
+    cb_func = cb_data_advanced_get(ctx, "tlsext_status_cb!!func");
+    cb_data = cb_data_advanced_get(ctx, "tlsext_status_cb!!data");
+
+    if ( ! SvROK(cb_func) || (SvTYPE(SvRV(cb_func)) != SVt_PVCV))
+	croak ("Net::SSLeay: tlsext_status_cb_invoke called, but not set to point to any perl function.\n");
+
+    len = SSL_get_tlsext_status_ocsp_resp(ssl, &p);
+    if (p) ocsp_response = d2i_OCSP_RESPONSE(NULL, &p, len);
+
+    ENTER;
+    SAVETMPS;
+
+    PUSHMARK(SP);
+    XPUSHs(sv_2mortal(newSViv(PTR2IV(ssl))));
+    PUSHs( sv_2mortal(newSViv(PTR2IV(ocsp_response))) );
+    XPUSHs(sv_2mortal(newSVsv(cb_data)));
+    PUTBACK;
+
+    nres = call_sv(cb_func, G_SCALAR);
+    OCSP_RESPONSE_free(ocsp_response);
+
+    SPAGAIN;
+
+    if (nres != 1)
+	croak("Net::SSLeay: tlsext_status_cb_invoke perl function did not return a scalar.\n");
+
+    res = POPi;
+
+    PUTBACK;
+    FREETMPS;
+    LEAVE;
+
+    return res;
+}
+
+#endif
+
 #if defined(SSL_F_SSL_SET_HELLO_EXTENSION) || defined(SSL_F_SSL_SET_SESSION_TICKET_EXT)
 
 int ssleay_session_secret_cb_invoke(SSL* s, void* secret, int *secret_len,
@@ -1083,8 +1155,115 @@
     }
 }
 
-/* ============= end of callback stuff ============== */
+/* ============= end of callback stuff, begin helper functions ============== */
 
+time_t ASN1_TIME_timet(ASN1_TIME *asn1t) {
+    struct tm t;
+    const char *p = (const char*) asn1t->data;
+    size_t msec = 0, tz = 0, i, l;
+    time_t result;
+    int adj = 0;
+
+    if (asn1t->type == V_ASN1_UTCTIME) {
+	if (asn1t->length<12 || asn1t->length>17) return 0;
+	if (asn1t->length>12) tz = 12;
+    } else {
+	if (asn1t->length<14) return 0;
+	if (asn1t->length>14) {
+	    if (p[14] == '.') {
+		msec = 14;
+		for(i=msec+1;i<asn1t->length && p[i]>='0' && p[i]<='9';i++) ;
+		if (i<asn1t->length) tz = i;
+	    } else {
+		tz = 14;
+	    }
+	}
+    }
+
+    l = msec ? msec : tz ? tz : asn1t->length;
+    for(i=0;i<l;i++) {
+	if (p[i]<'0' || p[i]>'9') return 0;
+    }
+
+    /* extract data and time */
+    memset(&t,0,sizeof(t));
+    if (asn1t->type == V_ASN1_UTCTIME) { /* YY - two digit year */
+	t.tm_year = (p[0]-'0')*10 + (p[1]-'0');
+	if (t.tm_year < 70) t.tm_year += 100;
+	i=2;
+    } else { /* YYYY */
+	t.tm_year = (p[0]-'0')*1000 + (p[1]-'0')*100 + (p[2]-'0')*10 + p[3]-'0';
+	t.tm_year -= 1900;
+	i=4;
+    }
+    t.tm_mon  = (p[i+0]-'0')*10 + (p[i+1]-'0') -1; /* MM, starts with 0 in tm */
+    t.tm_mday = (p[i+2]-'0')*10 + (p[i+3]-'0');    /* DD */
+    t.tm_hour = (p[i+4]-'0')*10 + (p[i+5]-'0');    /* hh */
+    t.tm_min  = (p[i+6]-'0')*10 + (p[i+7]-'0');    /* mm */
+    t.tm_sec  = (p[i+8]-'0')*10 + (p[i+9]-'0');    /* ss */
+
+    /* skip msec, because time_t does not support it */
+
+    if (tz) {
+	/* TZ is 'Z' or [+-]DDDD and after TZ the string must stop*/
+	if (p[tz] == 'Z') {
+	    if (asn1t->length>tz+1 ) return 0;
+	} else if (asn1t->length<tz+5 || (p[tz]!='-' && p[tz]!='+')) {
+	    return 0;
+	} else {
+	    if (asn1t->length>tz+5 ) return 0;
+	    for(i=tz+1;i<tz+5;i++) {
+		if (p[i]<'0' || p[i]>'9') return 0;
+	    }
+	    adj = ((p[tz+1]-'0')*10 + (p[tz+2]-'0'))*3600
+		+ ((p[tz+3]-'0')*10 + (p[tz+4]-'0'))*60;
+	    if (p[tz]=='+') adj*= -1; /* +0500: subtract 5 hours to get UTC */
+	}
+    }
+
+    result = mktime(&t);
+    if (result == -1) return 0; /* broken time */
+    return result + adj + ( t.tm_isdst ? 3600:0 );
+}
+
+X509 * find_issuer(X509 *cert,X509_STORE *store, STACK_OF(X509) *chain) {
+    int i;
+    X509 *issuer = NULL;
+
+    /* search first in the chain */
+    if (chain) {
+	for(i=0;i<sk_X509_num(chain);i++) {
+	    if ( X509_check_issued(sk_X509_value(chain,i),cert) == X509_V_OK ) {
+		TRACE(2,"found issuer in chain");
+		issuer = sk_X509_value(chain,i);
+	    }
+	}
+    }
+    /* if not in the chain it might be in the store */
+    if ( !issuer && store ) {
+	X509_STORE_CTX *stx = X509_STORE_CTX_new();
+	if (stx && X509_STORE_CTX_init(stx,store,cert,NULL)) {
+	    int ok = X509_STORE_CTX_get1_issuer(&issuer,stx,cert);
+	    if (ok<0) {
+		int err = ERR_get_error();
+		if(err) {
+		    TRACE(2,"failed to get issuer: %s",ERR_error_string(err,NULL));
+		} else {
+		    TRACE(2,"failed to get issuer: unknown error");
+		}
+	    } else if (ok == 0 ) {
+		TRACE(2,"failed to get issuer(0)");
+	    } else {
+		TRACE(2,"got issuer");
+	    }
+	}
+	if (stx) X509_STORE_CTX_free(stx);
+    }
+    return issuer;
+}
+
+/* ============= end of helper functions ============== */
+
 MODULE = Net::SSLeay		PACKAGE = Net::SSLeay          PREFIX = SSL_
 
 PROTOTYPES: ENABLE
@@ -2737,6 +2916,28 @@
         }
 
 void
+P_X509_get_ocsp_uri(cert)
+	X509 * cert
+    PPCODE:
+	AUTHORITY_INFO_ACCESS *info;
+	int i;
+	info = X509_get_ext_d2i(cert, NID_info_access, NULL, NULL);
+	if (!info) XSRETURN_UNDEF;
+
+	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++) {
+	    ACCESS_DESCRIPTION *ad = sk_ACCESS_DESCRIPTION_value(info, i);
+	    if (OBJ_obj2nid(ad->method) == NID_ad_OCSP
+		&& ad->location->type == GEN_URI) {
+		XPUSHs(sv_2mortal(newSVpv(
+		    (char*)ASN1_STRING_data(ad->location->d.uniformResourceIdentifier),
+		    ASN1_STRING_length(ad->location->d.uniformResourceIdentifier)
+		)));
+		if (GIMME == G_SCALAR) break; /* get only first */
+	    }
+	}
+
+
+void
 P_X509_get_ext_key_usage(cert,format=0)
         X509 * cert
         int format
@@ -3051,8 +3252,8 @@
      ASN1_TIME *s
      time_t t
 
-void
-ASN1_TIME_free(s)
+time_t
+ASN1_TIME_timet(s)
      ASN1_TIME *s
 
 ASN1_TIME *
@@ -5074,6 +5275,312 @@
 
 #endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+
+#if !defined(OPENSSL_NO_TLSEXT)
+
+int
+SSL_set_tlsext_status_type(SSL *ssl,int cmd)
+
+int
+SSL_CTX_set_tlsext_status_cb(ctx,callback,data=&PL_sv_undef)
+	SSL_CTX * ctx
+	SV * callback
+	SV * data
+    CODE:
+	RETVAL = 1;
+	if (callback==NULL || !SvOK(callback)) {
+	    SSL_CTX_set_tlsext_status_cb(ctx, NULL);
+	    cb_data_advanced_put(ctx, "tlsext_status_cb!!func", NULL);
+	    cb_data_advanced_put(ctx, "tlsext_status_cb!!data", NULL);
+	} else if (SvROK(callback) && (SvTYPE(SvRV(callback)) == SVt_PVCV)) {
+	    cb_data_advanced_put(ctx, "tlsext_status_cb!!func", newSVsv(callback));
+	    cb_data_advanced_put(ctx, "tlsext_status_cb!!data", newSVsv(data));
+	    SSL_CTX_set_tlsext_status_cb(ctx, tlsext_status_cb_invoke);
+	} else {
+	    croak("argument must be code reference");
+	}
+    OUTPUT:
+	RETVAL
+
+#endif
+
+OCSP_RESPONSE *
+d2i_OCSP_RESPONSE(pv)
+	SV *pv
+    CODE:
+	if (SvPOK(pv)) {
+	    const unsigned char *p;
+	    STRLEN len;
+	    p = SvPV(pv,len);
+	    RETVAL = d2i_OCSP_RESPONSE(NULL,&p,len);
+	}
+    OUTPUT:
+	RETVAL
+
+void
+i2d_OCSP_RESPONSE(r)
+	OCSP_RESPONSE * r
+    PPCODE:
+	STRLEN len;
+	unsigned char *pc,*pi;
+	if (!(len = i2d_OCSP_RESPONSE(r,NULL))) croak("invalid OCSP response");
+	pi = pc = calloc(len,sizeof(char));
+	if (!pc) croak("out of memory");
+	i2d_OCSP_RESPONSE(r,&pi);
+	XPUSHs(sv_2mortal(newSVpv(pc,len)));
+	free(pc);
+
+void
+OCSP_RESPONSE_free(r)
+    OCSP_RESPONSE * r
+
+
+OCSP_REQUEST *
+d2i_OCSP_REQUEST(pv)
+	SV *pv
+    CODE:
+	if (SvPOK(pv)) {
+	    const unsigned char *p;
+	    STRLEN len;
+	    p = SvPV(pv,len);
+	    RETVAL = d2i_OCSP_REQUEST(NULL,&p,len);
+	}
+    OUTPUT:
+	RETVAL
+
+void
+i2d_OCSP_REQUEST(r)
+	OCSP_REQUEST * r
+    PPCODE:
+	STRLEN len;
+	unsigned char *pc,*pi;
+	if (!(len = i2d_OCSP_REQUEST(r,NULL))) croak("invalid OCSP request");
+	pi = pc = calloc(len,sizeof(char));
+	if (!pc) croak("out of memory");
+	i2d_OCSP_REQUEST(r,&pi);
+	XPUSHs(sv_2mortal(newSVpv(pc,len)));
+	free(pc);
+
+
+void
+OCSP_REQUEST_free(r)
+    OCSP_REQUEST * r
+
+
+const char *
+OCSP_response_status_str(long status)
+
+long
+OCSP_response_status(OCSP_RESPONSE *r)
+
+void
+SSL_OCSP_cert2ids(ssl,...)
+	SSL *ssl
+    PPCODE:
+	SSL_CTX *ctx;
+	X509_STORE *store;
+	STACK_OF(X509) *chain;
+	X509 *cert,*issuer;
+	OCSP_CERTID *id;
+	int i;
+	STRLEN len;
+	unsigned char *pc,*pi;
+
+	if (!ssl) croak("not a SSL object");
+	ctx = SSL_get_SSL_CTX(ssl);
+	if (!ctx) croak("invalid SSL object - no context");
+	store = SSL_CTX_get_cert_store(ctx);
+	chain = SSL_get_peer_cert_chain(ssl);
+
+	for(i=0;i<items-1;i++) {
+	    cert = INT2PTR(X509*,SvIV(ST(i+1)));
+	    if (X509_check_issued(cert,cert) == X509_V_OK)
+		croak("no OCSP request for self-signed certificate");
+	    if (!(issuer = find_issuer(cert,store,chain)))
+		croak("cannot find issuer to certificate");
+	    if (!(id = OCSP_cert_to_id(EVP_sha1(),cert,issuer)))
+		croak("out of memory for generating OCSO certid");
+	    if (!(len = i2d_OCSP_CERTID(id,NULL)))
+		croak("OCSP certid has no length");
+	    pi = pc = calloc(len+1,sizeof(char));
+	    if (!pc) croak("out of memory");
+	    i2d_OCSP_CERTID(id,&pi);
+	    XPUSHs(sv_2mortal(newSVpv(pc,len)));
+	    free(pc);
+	}
+
+
+OCSP_REQUEST *
+OCSP_ids2req(...)
+    CODE:
+	OCSP_REQUEST *req;
+	OCSP_CERTID *id;
+	int i;
+
+	req = OCSP_REQUEST_new();
+	if (!req) croak("out of memory");
+	OCSP_request_add1_nonce(req,NULL,-1);
+
+	for(i=0;i<items;i++) {
+	    STRLEN len;
+	    const unsigned char *p = SvPV(ST(i),len);
+	    id = d2i_OCSP_CERTID(NULL,&p,len);
+	    if (!id) {
+		OCSP_REQUEST_free(req);
+		croak("failed to get OCSP certid from string");
+	    }
+	    OCSP_request_add0_id(req,id);
+	}
+	RETVAL = req;
+    OUTPUT:
+	RETVAL
+
+
+
+int
+SSL_OCSP_response_verify(ssl,rsp,svreq=NULL,flags=0)
+	SSL *ssl
+	OCSP_RESPONSE *rsp
+	SV *svreq
+	unsigned long flags
+    CODE:
+	SSL_CTX *ctx;
+	X509_STORE *store;
+	OCSP_BASICRESP *bsr;
+	OCSP_REQUEST *req = NULL;
+	int i;
+
+	if (!ssl) croak("not a SSL object");
+	ctx = SSL_get_SSL_CTX(ssl);
+	if (!ctx) croak("invalid SSL object - no context");
+
+	bsr = OCSP_response_get1_basic(rsp);
+	if (!bsr) croak("invalid OCSP response");
+
+	/* if we get a nonce it should match our nonce, if we get no nonce
+	 * it was probably pre-signed */
+	if (svreq && SvOK(svreq) &&
+	    (req = INT2PTR(OCSP_REQUEST*,SvIV(svreq)))) {
+	    i = OCSP_check_nonce(req,bsr);
+	    if ( i <= 0 ) {
+		if (i == -1) {
+		    TRACE(2,"SSL_OCSP_response_verify: no nonce in response");
+		} else {
+		    OCSP_BASICRESP_free(bsr);
+		    croak("nonce in OCSP response does not match request");
+		}
+	    }
+	}
+
+	if ((store = SSL_CTX_get_cert_store(ctx))) {
+	    /* add the SSL uchain to the uchain of the OCSP basic response, this
+	     * looks like the easiest way to handle the case where the OCSP
+	     * response does not contain the chain up to the trusted root */
+	    STACK_OF(X509) *chain = SSL_get_peer_cert_chain(ssl);
+	    for(i=0;i<sk_X509_num(chain);i++) {
+		if (!bsr->certs) bsr->certs = sk_X509_new_null();
+		sk_X509_push(bsr->certs,X509_dup(sk_X509_value(chain,i)));
+	    }
+	    TRACE(1,"run basic verify");
+	    RETVAL = OCSP_basic_verify(bsr, NULL, store, flags);
+	}
+	end:
+	OCSP_BASICRESP_free(bsr);
+    OUTPUT:
+	RETVAL
+
+
+void
+OCSP_response_results(rsp,...)
+	OCSP_RESPONSE *rsp
+    PPCODE:
+	OCSP_BASICRESP *bsr;
+	int i,want_array;
+	time_t nextupd = 0;
+
+	bsr = OCSP_response_get1_basic(rsp);
+	if (!bsr) croak("invalid OCSP response");
+
+	want_array = (GIMME == G_ARRAY);
+
+	for(i=1;i<items;i++) {
+	    STRLEN len;
+	    const char *error = NULL;
+	    OCSP_SINGLERESP *sir = NULL;
+	    STACK_OF(OCSP_SINGLERESP) *sks;
+	    OCSP_CERTID *certid = NULL;
+	    int k;
+	    SV *idsv = ST(i);
+	    const unsigned char *p = SvPV(idsv,len);
+
+	    if (!(certid = d2i_OCSP_CERTID(NULL,&p,len))) {
+		error = "failed to get OCSP certid from string";
+		goto end;
+	    }
+
+	    sks = bsr->tbsResponseData->responses;
+	    for(k=0;k<sk_OCSP_SINGLERESP_num(sks);k++) {
+		if (!OCSP_id_cmp(certid,sk_OCSP_SINGLERESP_value(sks,k)->certId)) {
+		    sir = sk_OCSP_SINGLERESP_value(sks,k);
+		    break;
+		}
+	    }
+	    if (!sir) {
+		error = "cannot find entry for certificate in OCSP response";
+	    } else if (!OCSP_check_validity(sir->thisUpdate,sir->nextUpdate,0,-1)) {
+		error = "response not yet valid or expired";
+	    } else if (sir->certStatus->type == V_OCSP_CERTSTATUS_REVOKED) {
+		error = "certificate is revoked";
+	    } else if (sir->certStatus->type != V_OCSP_CERTSTATUS_GOOD) {
+		error = "certificate status is unkown";
+	    }
+
+	    end:
+	    if (want_array) {
+		AV *idav = newAV();
+		av_push(idav, SvREFCNT_inc(idsv));
+		av_push(idav, error ? newSVpv(error,0) : newSV(0));
+		if (sir) {
+		    HV *details = newHV();
+		    av_push(idav,newRV_noinc((SV*)details));
+		    hv_store(details,"statusType",10,
+			newSViv(sir->certStatus->type),0);
+		    if (sir->nextUpdate) hv_store(details,"nextUpdate",10,
+			newSViv(ASN1_TIME_timet(sir->nextUpdate)),0);
+		    if (sir->thisUpdate) hv_store(details,"thisUpdate",10,
+			newSViv(ASN1_TIME_timet(sir->thisUpdate)),0);
+		    if (sir->certStatus->type == V_OCSP_CERTSTATUS_REVOKED) {
+			OCSP_REVOKEDINFO *rev = sir->certStatus->value.revoked;
+			hv_store(details,"revocationTime",14,newSViv(
+			    ASN1_TIME_timet(rev->revocationTime)),0);
+			hv_store(details,"revocationReason",16,newSViv(
+			    ASN1_ENUMERATED_get(rev->revocationReason)),0);
+			hv_store(details,"revocationReason_str",20,newSVpv(
+			    OCSP_crl_reason_str(ASN1_ENUMERATED_get(
+			    rev->revocationReason)),0),0);
+		    }
+		}
+		XPUSHs(sv_2mortal(newRV_noinc((SV*)idav)));
+	    } else if (!error) {
+		/* compute lowest nextUpdate */
+		time_t nu = ASN1_TIME_timet(sir->nextUpdate);
+		if (!nextupd || nextupd>nu) nextupd = nu;
+	    }
+
+	    if (certid) OCSP_CERTID_free(certid);
+	    if (error && !want_array) {
+		OCSP_BASICRESP_free(bsr);
+		croak(error);
+	    }
+	}
+	if (!want_array)
+	    XPUSHs(sv_2mortal(newSViv(nextupd)));
+
+
+
+#endif
+
 #if OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(OPENSSL_NO_TLSEXT)
 
 int
Index: helper_script/regen_openssl_constants.pl
===================================================================
--- helper_script/regen_openssl_constants.pl	(revision 402)
+++ helper_script/regen_openssl_constants.pl	(working copy)
@@ -572,3 +572,13 @@
 XN_FLAG_SEP_MULTILINE
 XN_FLAG_SEP_SPLUS_SPC
 XN_FLAG_SPC_EQ
+TLSEXT_STATUSTYPE_ocsp
+OCSP_RESPONSE_STATUS_SUCCESSFUL
+OCSP_RESPONSE_STATUS_MALFORMEDREQUEST
+OCSP_RESPONSE_STATUS_INTERNALERROR
+OCSP_RESPONSE_STATUS_TRYLATER
+OCSP_RESPONSE_STATUS_SIGREQUIRED
+OCSP_RESPONSE_STATUS_UNAUTHORIZED
+V_OCSP_CERTSTATUS_GOOD
+V_OCSP_CERTSTATUS_REVOKED
+V_OCSP_CERTSTATUS_UNKNOWN
Index: lib/Net/SSLeay.pm
===================================================================
--- lib/Net/SSLeay.pm	(revision 402)
+++ lib/Net/SSLeay.pm	(working copy)
@@ -339,7 +339,18 @@
     use_certificate_ASN1
     use_certificate_file
     write
-
+    d2i_OCSP_RESPONSE
+    i2d_OCSP_RESPONSE
+    OCSP_RESPONSE_free
+    d2i_OCSP_REQUEST
+    i2d_OCSP_REQUEST
+    OCSP_REQUEST_free
+    OCSP_cert2ids
+    OCSP_ids2req
+    OCSP_response_status
+    OCSP_response_status_str
+    OCSP_response_verify
+    OCSP_response_results
 );
 
 sub AUTOLOAD {
Index: lib/Net/SSLeay.pod
===================================================================
--- lib/Net/SSLeay.pod	(revision 402)
+++ lib/Net/SSLeay.pod	(working copy)
@@ -393,6 +393,188 @@
         error reading CRL....
     }
 
+Usually the URLs where you can download the CRLs is contained in the certificate
+itself and you can extract them with
+
+    my @url = Net::SSLeay::P_X509_get_crl_distribution_points($cert)
+
+But there is no automatic downloading of the CRLs and often these CRLs are too
+huge to just download them to verify a single certificate.
+Also, these CRLs are often in DER format which you need to convert to PEM before
+you can use it:
+
+    openssl crl -in crl.der -inform der -out crl.pem
+
+So as an alternative for faster and timely revocation checks you better use
+the Online Status Revocation Protocol (OCSP).
+
+=head2 Certificate verification and Online Status Revocation Protocol (OCSP)
+
+While checking for revoked certificates is possible and fast with Certificate
+Revocation Lists, you need to download the complete and often huge list before
+you can verify a single certificate.
+
+A faster way is to ask the CA to check the revocation of just a single or a few
+certificates using OCSP. Basically you generate for each certificate an
+OCSP_CERTID based on the certificate itself and its issuer, put the ids
+togetether into an OCSP_REQUEST and send the request to the URL given in the
+certificate.
+
+As a result you get back an OCSP_RESPONSE and need to check the status of the
+response, check that it is valid (e.g. signed by the CA) and finally extract the
+information about each OCSP_CERTID to find out if the certificate is still valid
+or got revoked.
+
+With Net::SSLeay this can be done like this:
+
+    # get id(s) for given certs, like from get_peer_certificate
+    # or get_peer_cert_chain. This will croak if
+    # - one tries to make an OCSP_CERTID for a self-signed certificate
+    # - the issuer of the certificate cannot be found in the SSL objects
+    #   store, nor in the current certificate chain
+    my $cert = Net::SSLeay::get_peer_certificate($ssl);
+    my $id = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
+    die "failed to make OCSP_CERTID: $@" if $@;
+
+    # create OCSP_REQUEST from id(s)
+    # Multiple can be put into the same request, if the same OCSP responder
+    # is responsible for them.
+    my $req = Net::SSLeay::OCSP_ids2req($id);
+
+    # determine URI of OCSP responder
+    my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert);
+
+    # Send stringified OCSP_REQUEST with POST to $uri.
+    # We can ignore certificate verification for https, because the OCSP
+    # response itself is signed.
+    my $ua = HTTP::Tiny->new(verify_SSL => 0);
+    my $res = $ua->request( 'POST',$uri, {
+	headers => { 'Content-type' => 'application/ocsp-request' },
+	content => Net::SSLeay::i2d_OCSP_REQUEST($req)
+    });
+    my $content = $res && $res->{success} && $res->{content}
+	or die "query failed";
+
+    # Extract OCSP_RESPONSE.
+    # this will croak if the string is not an OCSP_RESPONSE
+    my $resp = eval { Net::SSLeay::d2i_OCSP_RESPONSE($content) };
+
+    # Check status of response.
+    my $status = Net::SSLeay::OCSP_response_status($resp);
+    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) 
+    	die "OCSP response failed: ".
+	    Net::SSLeay::OCSP_response_status_str($status);
+    }
+
+    # Verify signature of response and if nonce matches request.
+    # This will croak if there is a nonce in the response, but it does not match
+    # the request. It will return false if the signature could not be verified,
+    # in which case details can be retrieved with Net::SSLeay::ERR_get_error.
+    # It will not complain if the response does not contain a nonce, which is
+    # usually the case with pre-signed responses.
+    if ( ! eval { Net::SSLeay::OCSP_response_verify($ssl,$resp,$req) }) {
+    	die "OCSP response verification failed";
+    }
+
+    # Extract information from OCSP_RESPONSE for each of the ids.
+
+    # If called in scalar context it will return the time (as time_t), when the
+    # next update is due (minimum of all successful responses inside $resp). It
+    # will croak on the following problems:
+    # - response is expired or not yet valid
+    # - no response for given OCSP_CERTID
+    # - certificate status is not good (e.g. revoked or unknown)
+    if ( my $nextupd = eval { Net::SSLeay::OCSP_response_results($resp,$id) }) {
+    	warn "certificate is valid, next update in ".
+	    ($nextupd-time())." seconds\n";
+    } else {
+    	die "certificate is not valid: $@";
+    }
+
+    # Bug in array context it will return detailled information about each given
+    # OCSP_CERTID instead croaking on errors:
+    my @results = Net::SSLeay::OCSP_response_results($resp,@ids);
+    for my $r (@results) {
+    	print Dumper($r);
+	# @results are in the same order as the @ids and contain:
+	# $r->[0] - OCSP_CERTID
+	# $r->[1] - undef if no error (certificate good) OR error message as string
+	# $r->[2] - hash with details:
+	#   thisUpdate - time_t of this single response
+	#   nextUpdate - time_t when update is expected
+	#   statusType - integer: 
+	#      V_OCSP_CERTSTATUS_GOOD(0)
+	#      V_OCSP_CERTSTATUS_REVOKED(1)
+	#      V_OCSP_CERTSTATUS_UNKNOWN(2)
+	#   revocationTime - time_t (only if revoked)
+	#   revocationReason - integer (only if revoked)
+	#   revocationReason_str - reason as string (only if revoked)
+    }
+
+To further speed up certificate revocation checking one can use a TLS extension
+to instruct the server to staple the OCSP response:
+
+    # set TLS extension before doing SSL_connect
+    Net::SSLeay::set_tlsext_status_type($ssl, 
+        Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
+
+    # setup callback to verify OCSP response
+    my $cert_valid = undef;
+    Net::SSLeay::CTX_set_tlsext_status_cb($context,sub {
+    	my ($ssl,$resp) = @_;
+	if (!$resp) {
+	    # Lots of servers don't return an OCSP response.
+	    # In this case we must check the OCSP status outside the SSL
+	    # handshake.
+	    warn "server did not return stapled OCSP response\n";
+	    return 1;
+	}
+	# verify status
+	my $status = Net::SSLeay::OCSP_response_status($resp);
+	if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
+	    warn "OCSP response failure: $status\n";
+	    return 1;
+	}
+	# verify signature - we have no OCSP_REQUEST here to check nonce
+	if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
+	    warn "OCSP response verify failed\n";
+	    return 1;
+	}
+	# check if the certificate is valid
+	# we should check here against the peer_certificate
+	my $cert = Net::SSLeay::get_peer_certificate();
+	my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
+	    warn "cannot get certid from cert: $@";
+	    $cert_valid = -1;
+	    return 1;
+	};
+
+	if ( $nextupd = eval { 
+	    Net::SSLeay::OCSP_response_results($resp,$certid) }) {
+	    warn "certificate not revoked\n";
+	    $cert_valid = 1;
+	} else {
+	    warn "certificate not valid: $@";
+	    $cert_valid = 0;
+	}
+    });
+
+    # do SSL handshake here
+    ....
+    # check if certificate revocation was checked already
+    if ( ! defined $cert_valid) {
+	# check revocation outside of SSL handshake by asking OCSP responder
+	...
+    } elsif ( ! $cert_valid ) {
+	die "certificate not valid - closing SSL connection";
+    } elsif ( $cert_valid<0 ) {
+	die "cannot verify certificate revocation - self-signed ?";
+    } else {
+	# everything fine
+	...
+    }
+
+
 =head2 Using Net::SSLeay in multi-threaded applications
 
 B<IMPORTANT: versions 1.42 or earlier are not thread-safe!>
Index: t/external/ocsp.t
===================================================================
--- t/external/ocsp.t	(revision 0)
+++ t/external/ocsp.t	(working copy)
@@ -0,0 +1,231 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use Test::More;
+use IO::Socket::INET;
+use Net::SSLeay;
+
+#$Net::SSLeay::trace=3;
+
+my @tests = (
+    {
+	# this should give us OCSP stapling
+	host => 'www.live.com',
+	port => 443,
+	fingerprint => '10c56ee9e2acaf2e77caeb7072bf6522dd7422b8',
+	ocsp_staple => 1,
+    },
+    {
+	# no OCSP stapling yet
+	host => 'www.google.com',
+	port => 443,
+	fingerprint => '007a5ab302f14446e2ea24d3a829de22ba1bf950',
+    },
+    {
+	# this is revoked
+	host => 'revoked.grc.com',
+	port => 443,
+	fingerprint => '34703c40093461ad3ce087e161c7b7f42abe770c',
+	expect_error => qr/revoked/,
+    },
+);
+
+plan tests => 0+@tests;
+
+
+my $timeout = 10; # used to TCP connect and SSL connect
+my $http_ua = eval { require HTTP::Tiny } && HTTP::Tiny->new(verify_SSL => 0);
+
+Net::SSLeay::randomize();
+Net::SSLeay::load_error_strings();
+Net::SSLeay::ERR_load_crypto_strings();
+Net::SSLeay::SSLeay_add_ssl_algorithms();
+my $sha1 = Net::SSLeay::EVP_get_digestbyname('sha1');
+
+TEST:
+for my $test (@tests) {
+    my $cleanup = __cleanup__->new;
+    SKIP: {
+	my $cl = IO::Socket::INET->new(
+	    PeerAddr => $test->{host},
+	    PeerPort => $test->{port},
+	    Timeout => $timeout,
+	);
+	skip "TCP connect to $test->{host}:$test->{port} failed: $!",1
+	    if !$cl;
+	diag("tcp connect to $test->{host}:$test->{port} ok");
+
+	my $ctx = Net::SSLeay::CTX_new() or die "failed to create CTX";
+	my $ssl = Net::SSLeay::new($ctx) or die "failed to create SSL";
+
+	# enable verification with hopefully usable CAs
+	Net::SSLeay::CTX_set_default_verify_paths($ctx);
+	Net::SSLeay::CTX_load_verify_locations($ctx,
+	    Mozilla::CA::SSL_ca_file(),'')
+	    if eval { require Mozilla::CA };
+	Net::SSLeay::CTX_set_verify($ctx,Net::SSLeay::VERIFY_PEER(),undef);
+
+	# setup TLS extension and callback to catch stapled OCSP response
+	my $stapled_response;
+	Net::SSLeay::set_tlsext_status_type($ssl, 
+	    Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
+	Net::SSLeay::CTX_set_tlsext_status_cb($ctx,sub {
+	    my ($ssl,$resp) = @_;
+	    diag("got ".($resp ? '':'no ')."stapled OCSP response");
+	    return 1 if ! $resp;
+	    $stapled_response = Net::SSLeay::i2d_OCSP_RESPONSE($resp);
+	    return 1;
+	});
+
+	# non-blocking SSL_connect with timeout
+	$cl->blocking(0);
+	Net::SSLeay::set_fd($ssl,fileno($cl));
+	my $end = time() + $timeout;
+	my $rv;
+	while (($rv = Net::SSLeay::connect($ssl)) < 0) {
+	    my $to = $end-time();
+	    $to<=0 and last;
+	    my $err = Net::SSLeay::get_error($ssl,$rv);
+	    vec( my $vec = '',fileno($cl),1) = 1;
+	    if ( $err == Net::SSLeay::ERROR_WANT_READ()) {
+		select($vec,undef,undef,$to);
+	    } elsif ( $err == Net::SSLeay::ERROR_WANT_WRITE()) {
+		select(undef,$vec,undef,$to);
+	    }
+	}
+	skip "SSL_connect with $test->{host}:$test->{port} failed: ".
+	    Net::SSLeay::print_errs(''),1
+	    if $rv<=0;
+	diag("SSL_connect ok");
+
+	# make sure we talk to the right party, e.g. no SSL interception
+	my $leaf_cert = Net::SSLeay::get_peer_certificate($ssl);
+	$cleanup->add(sub { Net::SSLeay::X509_free($leaf_cert) }) if $leaf_cert;
+	my $fp = $leaf_cert 
+	    && unpack("H*",Net::SSLeay::X509_digest($leaf_cert,$sha1));
+	skip "could not get fingerprint",1 if !$fp;
+	skip "bad fingerprint $fp for $test->{host}:$test->{port}",1
+	    if $fp ne $test->{fingerprint};
+	diag("fingerprint matches");
+
+	if ( $test->{ocsp_staple} && ! $stapled_response ) {
+	    fail("did not get expected stapled OCSP response on $test->{host}:$test->{port}");
+	    next TEST;
+	}
+
+	# create OCSP_REQUEST for all certs
+	my @requests;
+	for my $cert (Net::SSLeay::get_peer_cert_chain($ssl)) {
+	    my $subj = Net::SSLeay::X509_NAME_oneline(
+		Net::SSLeay::X509_get_subject_name($cert));
+	    my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert);
+	    if (!$uri) {
+		diag("no OCSP URI for cert $subj");
+		next;
+	    }
+	    my $id = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
+		fail("failed to get OCSP_CERTIDs for cert $subj: $@");
+		next TEST;
+	    };
+	    my $req = Net::SSLeay::OCSP_ids2req($id);
+	    push @requests, [ $uri,$req,$id,$subj ];
+	    $cleanup->add(sub { Net::SSLeay::OCSP_REQUEST_free($req) });
+	}
+	if (!@requests) {
+	    fail("no certificate checks for $test->{host}:$test->{port}");
+	    next TEST;
+	}
+
+	my $check_response = sub {
+	    my ($resp,$req,$id,$expect_error) = @_;
+	    if ( Net::SSLeay::OCSP_response_status($resp) 
+		!= Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
+		diag("response bad status");
+		return undef;
+	    } elsif ( ! eval { 
+		Net::SSLeay::OCSP_response_verify($ssl,$resp,$req) }) {
+		return [ undef,"cannot verify response: $@" ];
+	    }
+	    # extract result for id 
+	    my ($status) = Net::SSLeay::OCSP_response_results($resp,$id);
+	    return [ undef,"no data for cert in response: $status->[1]" ]
+		if ! $status->[2];
+	    if ($expect_error) {
+		return [ undef,
+		    "unexpected error (expected $expect_error): $status->[1]" ]
+		    if !$status->[1] or $status->[1] !~ $expect_error;
+		diag("expected error: $status->[1]");
+	    } elsif ($status->[1]) {
+		return [ undef, "unexpected error: $status->[1]" ]
+	    } else {
+		diag("expected good: nextUpd=".localtime($status->[2]{nextUpdate}));
+	    }
+	    return $status;
+	};
+
+	if ($stapled_response) {
+	    my $stat = $check_response->(
+		Net::SSLeay::d2i_OCSP_RESPONSE($stapled_response),
+		undef, # no OCSP_REQUEST
+		$requests[0][2], # stapled response is for the leaf certificate
+		$test->{expect_error}
+	    );
+	    if (!$stat->[0]) {
+		fail($stat->[1]);
+		next TEST;
+	    }
+	}
+
+	for(my $i=0;$i<@requests;$i++) {
+	    my ($uri,$req,$id,$subj) = @{$requests[$i]};
+	    if ( ! $http_ua ) {
+		diag("no HTTP: skip checking $uri | $subj");
+		next
+	    }
+	    my $res = $http_ua->request('POST',$uri, {
+		headers => { 'Content-type' => 'application/ocsp-request' },
+		content => Net::SSLeay::i2d_OCSP_REQUEST($req),
+		timeout => $timeout,
+	    });
+	    if (!$res->{success}) {
+		if ($res->{status} == 599) {
+		    # internal error, assume network problem
+		    diag("disabling HTTP because of $http_ua->{reason}");
+		    $http_ua = undef;
+		}
+		diag("$http_ua->{reason}: skip checking $uri | $subj");
+		next;
+	    }
+	    my $resp = eval { Net::SSLeay::d2i_OCSP_RESPONSE($res->{content}) };
+	    if (!$resp) {
+		diag("bad OCSP response($@): skip checking $uri | $subj");
+		next;
+	    }
+	    my $stat = $check_response->(
+		$resp,
+		$req,
+		$id,
+		($i>0) ? undef:$test->{expect_error},
+	    );
+	    if (!$stat->[0]) {
+		fail($stat->[1]);
+		next TEST;
+	    }
+	}
+
+	pass("OCSP test $test->{host}:$test->{port} ok");
+    }
+}
+
+{
+    # cleanup stuff when going out of scope
+    package __cleanup__;
+    sub new { bless [],shift };
+    sub add { my $self = shift; push @$self,@_ }
+    sub DESTROY {
+	my $self = shift;
+	&$_ for(@$self)
+    }
+}
+
Index: typemap
===================================================================
--- typemap	(revision 402)
+++ typemap	(working copy)
@@ -64,6 +64,8 @@
 const ASN1_OBJECT *       T_PTR
 STACK_OF(ASN1_OBJECT) * T_PTR
 ENGINE *         T_PTR
+OCSP_RESPONSE *	T_PTR
+OCSP_REQUEST *	T_PTR
 pem_password_cb *  T_PTR
 generate_key_cb *  T_PTR
 callback_ret_int * T_PTR
